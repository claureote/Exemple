type RefContract is string;
type Position is  ( quantity : float, average_price float);

subtype Portfolio is signal of (dictionary of (RefContract, Position)) ;
/*
-   We could say that a portfolio is just a dictionary/list of contract because quantity * asset is still a contract
-   But I find this model more practical...
*/

type Direction is enum{"Buy","Sell"};
type Trade is (ref : RefContract, quantity: float, direction : Direction, price :float, ref_currency :RefCurrency);

/*
*************** Built-in operators: ***********************

operations ( product  : contract) -> observation of (list of Trade)

    -   "operations" broadcast the Real Time flows generated by the product through an observation of list of contract
    -   We could simplify by removing list of and stick only to observation of trade (or even simpler :contract)
        because contract1 +/- contract2 is still contract but the list are easier to deal with (add position in
        portfolio  or merge portfolio
    -   In fact operation broadcast a simpler version of trade because price is 0

ContractFromRef (ref_contract : RefContract) -> contract

---- Methods in Top Scope ------

-For List
public static List<Tresult> Map( List<T> list, Function<T,Tresult> func);
public static Tresult Aggregate (T seed, List<T> list, Function<Tresult,T,Tresult> func);

-Tools
public static Dictionary<RefContract, Position>
    TradeToPositions (
                        List<Trade> trades_list ,
                        dictionary <RefContract, Position> init =null;
                        )
{
    string ref_asset;
    Dictionary of (string, Position) positions = init ?? new();
    foreach(var trade in trades_list) {
        ref_asset = trade.ref_asset;
        if (positions.ContainsKey(ref)){
            positions[ref_asset] =
                (   positions[ref_asset].quantity + (trade.direction=="Buy"?1:-1)*trade.quantity ,
                    (positions[ref_asset].quantity * positions[ref_asset].average_price
                                        + trade.quantity * trade.price )
                                    / (positions[ref_asset].quantity + trade.quantity)
                );
        }
        else {
            positions[ref_asset] =
                (   (trade.direction=="Buy"?1:-1)*trade.quantity ,
                     trade.price
                );
        }
        position[ref_currency] =
                (   positions[ref_asset].quantity + (trade.direction=="Buy"?1:-1)*trade.quantity * trade.price ,
                    0
                );
    }
    return positions;
}

public static TradeScale (double scale, Trade trade) =>
    (   trade.RefContract,
        scale*trade.quantity,
        trade.direction ,
        trade.price,
        trade.ref_currency);

public static List<Trade> Merge (List<Trade> list1 ,List<Trade> list2 )
{
    List <Trade> trades = new(list1);
    list2.foreach( x=> trades.Add(x));
    return trades;
}

public static List<Trade> Merge ( List<List<Trade>> lists )
{
    List <Trade> trades_list = new();
    foreach (var list in lists)
    {
        trades_list.AddRange (list);
    }
    return trades_list;
}

********************* */

block TradeToPortfolio return Portfolio
{
    init_portfolio : dictionary of (RefContract, Position);
    trades      : observation of (list of Trade);

    portfolio(0) = init_portfolio;
    portfolio(trades) = TradeToPositions( trades , portfolio(trades-1) ) ;

    return portfolio;
}

block PortFolioToTrade
{
    init_portfolio      : dictionary of (RefContract, Position);
    in_out_trades       : observation of Trade;

    portfolio(0) = init_portfolio;

    trades_from_contract_in_portfolio=
        Map(
            portfolio,
            x=> Merge(TradeScale(x.value.quantity, operations (ContractValue(x.key))))
            );

    all_trades = Merge(trades_from_contract_in_portfolio,in_out_trades);

    portfolio(all_trades)=TradeToPortfolio(all_trades,init_portfolio);
}
